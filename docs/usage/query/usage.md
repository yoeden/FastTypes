# Query

## Content

**[Intro](#heading--intro)**

**[Quick start](#heading--quickstart)**
  * [Example](#heading--quickstart-example)

**[Api](#heading--api)**
  * [Start](#heading--api-start)
  * [Assembly](#heading--api-assembly)
  * [Types](#heading--api-targets)
  * [Criterias](#heading--api-criterias)
  * [Groups](#heading--api-groups)
  * [Snapshot](#heading--api-snapshot)
  * [Scan](#heading--api-scan)
    * [FindGroupedTypes](#heading--api-scan-group)
    * [FindTypes](#heading--api-scan-single)
  * [Extensibility](#heading--api-extensibility)
    * [Custom Criterias](#heading--api-extensibility-criterias)
    * [Scan With Snapshot](#heading--api-extensibility-scan)
    * [Tags](#heading--api-extensibility-tags)
    * [Custom Action](#heading--api-extensibility-action)

## <div id="heading--intro"/> Intro

Assembly scanning is a key part in services reflection and dynamic programming.
Some of many uses for it are : 
* Services discovery (DI)
* Plugin Functionally (PlugNPlay)
* Project mapping (EF or Runtime type checking)
* More..

There aren't many assembly scanning libraries out there, and the ones that exists offers low to poor performance and somewhat basic extensibility.

## <div id="heading--quickstart"/> Quick start

### <div id="heading--quickstart-example"/> Example

If we want to scan, for all public types that generated by the compiler in our assembly : 
```csharp
var compilerGeneratedTypes = FastType
    .Query()
    .FromEntryAssembly()
    .TargetAllTypes()
    .WithAttribute<CompilerGeneratedAttribute>()
    .FindTypes();
```

and the result is : 
```
Program
Benchmarks+<CreateObjects>d__3
```

We can see that we have a lambda that got translated into a class (probably closure).

## <div id="heading--api"/> Api

### <div id="heading--api-start"/> Start

To start a query, call the `Query()` method from the `FastType` factory class.
This will return a new query builder.

The flow expected flow is :
New Builder -> Choose assemblies -> Target Types -> Apply Criterias -> [Optional] Add Tags -> Create immutable copy of the query (snapshot) -> Operate (in the example above, we ran a scan).

### <div id="heading--api-assembly"/> Assembly

At the first step, choose an assemblies to scan from :

| Name                  | What it scans                                                                              |
| --------------------- | ------------------------------------------------------------------------------------------ |
| FromAssembly          | From a given assembly                                                                      |
| FromAssemblies        | From given assemblies                                                                      |
| FromExecutingAssembly | From executing assembly (Will the be the FastType library since execution will pass to it) |
| FromCallingAssembly   | From the calling assembly (The assembly that passes the execution to FastType)             |
| FromEntryAssembly     | From the assembly that started running the process                                         |
| FromAllAssemblies     | From all available assemblies in the current AppDomain                                     |
| AssemblyContaining    | Assembly containing the current type                                                       |

### <div id="heading--api-targets"/> Types

At the second step, choose the types you wish apply the scan for :

| Name        | Includes                                                     |
| ----------- | ------------------------------------------------------------ |
| Classes     | All classes, abstract classes, partial class, nested classes |
| Interfaces  | All interfaces, nested interfaces                            |
| Enums       | All Enums                                                    |
| Value Types | All Value Types                                              |

### <div id="heading--api-criterias"/> Criterias

At the third step, choose the criterias to apply on given types

Example for some : 
* **AssignableTo** - Checks if given type matches types from assembly (supports generics).
* **PropertyOfType** - Checks if given type contains a property with a given type.
* **NotPublic** - Check if type is not public (internal, protected, private).
* **...**

> [!NOTE]
> By default query scan only for public.


### <div id="heading--api-groups"/> Groups

Queries are groups of target types and criterias.
By default, there is a single group that is being created unless `And()` method is being used.
```csharp
var c = FastType
    .Query()
    .FromEntryAssembly()

    // First group
    .TargetAllClasses()
    .AssignableTo<IService>()

    // Query another group of criterias
    .And()

    // Second group
    .TargetAllValueTypes()
    .AssignableTo<IService2>()

    ...
    ;
```

> [!TIP]
> It is much more effiecent to use groups than multiple scans, since we dont load the assemblies again for each query.

### <div id="heading--api-snapshot"/> Snapshot

Snapshots are the last (but not final) step of the query.
Each query action must be perfomed on an immutable copy of the query builder, hence snapshot.

Snapshot contains : 
* **Target assemblies**
* **Groups**
  * **Applied criterias (including target types criteria)**
  * **Tags**

Snapshoting a query builder doesn't seal the builder, but takes a _snapshot_ of its current state, 
the query builder can be use further on.

For example : 
```
//Create a query builder
var q = FastType
    .Query()
    .FromEntryAssembly()
    .TargetAllTypes()
    .WithAttribute<CompilerGeneratedAttribute>();

//Grab a snapshot that is ready for action of the current query builder state
var snapshot = q.Snapshot();

//Grab another snapshot current query builder state (same as before with WithPropertyOfType).
var snapshot2 = q
    .WithPropertyOfType<int>()
    .Snapshot();
```

### <div id="heading--api-scan"/> Scan

Scan can be applied using the `FindTypes` and `FindGroupedTypes` methods.
This methods acts as [extensions](#heading--api-extensibility).

#### <div id="heading--api-scan-group"/> FindGroupedTypes
`FindGroupedTypes` grabs a snapshot of the query -> Load assemblies -> Apply criterias to filter types -> Group results by groups defined in the builder -> returns `IReadOnlyList<IReadOnlyList<Type>>`.

The first list is the list of groups (index is respected as the builder order), 
the second list is the resulted types inside the group.

```csharp
var groups = FastType
    .Query()
    .FromEntryAssembly()
    .TargetAllTypes()
    .WithAttribute<CompilerGeneratedAttribute>()
    .FindGroupedTypes();
```

> [!NOTE]
> Duplicate may occur between groups, depends on the query (if both query are the same, both grouped results will be the same).


#### <div id="heading--api-scan-single"/> FindTypes
`FindTypes` grabs a snapshot of the query -> Load assemblies -> Apply criterias to filter types -> aggregate all the types from all groups -> returns `IReadOnlyList<Type>`.

```csharp
var types = FastType
    .Query()
    .FromEntryAssembly()
    .TargetAllTypes()
    .WithAttribute<CompilerGeneratedAttribute>()
    .FindTypes();
```

> [!NOTE]
> Duplicate will be eliminated, each type is guaranteed to be unique.


### <div id="heading--api-extensibility"/> Extensibility

FastType strongly believes in extensibility (and perfomance of course).
The query api is written with extensibility in mind.

#### <div id="heading--api-extensibility-criterias"/> Custom Criterias

Query builder has a `WithCriteria` method, allowing the developer to add a custom criteria based on his needs.
Simply implement the `ITypeQueryCriteria` interface.

> [!NOTE]
> The priority property helps the scan to optimize criteria order.
> Low priority is for wasteful and slow criterias (better to apply last).
> High priority is for light and fast criterias (better to apply first).
> See `QueryCriteriaPriority` for more information.

> [!TIP]
> It is best to write an extension method that uses internally `WithCriteria` to provide a better name for the builder flow.
> For example, `...TargetClasses().ThatEndsWith("Tests")...` is better than `...TargetClasses().WithCriteria(new TypeEndsWithCriteria("Tests"))...`.

#### <div id="heading--api-extensibility-scan"/> Scan with snapshot

If you want to use snapshot, perphaps to get the tags related to each group, but want to scanned type as well,
use the same methods as applied on the query builder, the `FindTypes` and `FindGroupedTypes` methods.

#### <div id="heading--api-extensibility-tags"/> Tags

An optional addition to the third step in the query builder, is to add tags to a current query group.
A example of good use case for tags is DI.
```csharp
var compilerGeneratedTypes = FastType
    .Query()
    .FromEntryAssembly()
    .TargetAllTypes()
    .AssignableTo<IService>()
    .AsSelf()
    .WithTransientLifetime()
    ...
    ;
```

`WithTransientLifetime` can be an [extension method](#heading--api-extensibility) that sets its lifetime as a tag, and retreive it later from a [query snapshot](#heading--api-snapshot).

```csharp
public enum ServiceLifetime
{
    Singelton,
    Transient,
}

...

// Set a tag for current query group
public static ITypeQueryBuilderCriterias WithTransientLifetime(this ITypeQueryBuilderCriterias query)
{
    return query.Tag(ServiceLifetime.Transient);
}

...

// Later when some action is perfomed on the query 
public void OnCustomAction(TypeQuerySnapshot snapshot)
{
    for(int i = 0; i < snapshot.Count; i++)
    {
        var group = snapshot.Groups[i];

        // Get lifetime associated with current group
        group.Tags.TryGet<ServiceLifetime>(out var lifetime);
    }
}
```

#### <div id="heading--api-extensibility-action"/> Custom action

If you want to implement a custom action on the query builder, write an extension method on the `ITypeQueryBuilderPreparation`, which exposes the `Snapshot()` method to create a snapshot of the current query.

Take a look on `TypeQueryInstanciateExt` for an example reference.